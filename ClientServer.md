# Предварительные сведения

В этом документе описаны основные принципы клиент-серверного взаимодействия в игре-прототипе [Two Worlds](http://twoworlds.azurewebsites.net/). Основные игровые возможности:
* Игрок управляет одним персонажем, который может стрелять и перемещаться по игровому миру в двумерной плоскости (то есть в двух направлениях - влево-вправо и вверх-вниз).
* Возможности персонажа (такие, как его скорость, наносимый урон и так далее) определяются в момент его выбора. Реализовано всего два вида таких персонажей. Один маленький, ездит быстро, стреляет слабо. Второй побольше, ездит медленнее и наносит больше урона. Первый стреляет снарядами, которые движутся прямолинейно и наносят урон первому попавшемуся противнику. Второй стреляет снарядами, которые наносят урон лишь в своей конечной области.
* Сервер управляет двумя видами противников. Первый (и основной вид) - это так называемые башни. Они всегда располагаются в фиксированных местах карты и атакуют игроков, если те приблизятся на определённую дистанцию. Второй вид - это собственно так называемые противники, которые представляют собой перемещаемые пассивные сущности, появляющиеся в окрестности каждой башни. Они совершают хаотические движения. При получении урона от игрока, они начинают двигаться в его сторону и атаковать. В окрестности каждой башни может быть лишь фиксированное количество этих вторичных сущностей. При уничтожении одной, тут же появляется её замена.
* При уничтожении кого-либо (другого игрока, противника или башни) с некоторой вероятностью выпадает объект, который восстанавливает часть жизни (игрока или противника). Если жизнь и так максимальна, то максимальный уровень повышается на некоторую небольшую величину.
* Сервер полностью авторитарный и осуществляет контроль за всеми игровыми событиями (нанесённый урон, где кто находится, области проходимости и так далее).
* Есть чат с автоматической фильтрацией ненормативной лексики. Этот чат общий без каких-либо разделений по областям, комнатам или чего-то подобного.

Сервер написан на основе [SmartFox server](https://www.smartfoxserver.com/). Сам SmartFox написан на Java и имеет клиентские библиотеки на многих языках (C#, JavaScript, Java, Objective-C, C++, ActionScript). Данное руководство имеет целью описать все необходимые сведения, достаточные для написания собственного игрового клиента (в том числе и бота). Если что-то не работает или есть вопросы - почта cgproggame@gmail.com

# Передаваемые данные от клиентов

Со стороны клиента на сервер можно передавать только четыре команды: две типа ExtensionRequest, одна типа PublicMessageRequest и команда логина.

Первая команда типа ExtensionRequest - **RPCClientSendMovementKey.** Она вызывается в случаях, когда игрок начинает или заканчивает движение и содержит информацию как о направлении движения, так и о направлении, куда он смотрит (эти направления не обязательно совпадают, так как игрок может ехать направо, а стрелять налево). Формат данных:

Поле | Тип | Примечание
--- | --- | ---
dirIndex | Byte | Принимает значения 0, 1, ..., 8. 0 означает, что движения нет, 1 - движение вверх, 2 - движение вверх-налево, 3 - налево, 4 - налево-вниз, 5 - вниз, 6 - вниз-направо, 7 - направо, 8 - вверх-направо.
angle | Float | Угол направления в радианах, вычисляемый от положительного направления оси OX против часовой стрелки

Вторая команда типа ExtensionRequest - **RPCFire.** Она вызывается в случае, если игрок нажал кнопку стрельбы и содержит информацию о координатах места, куда был сделан выстрел (то есть куда клиент кликнул мышкой) и направлении выстрела. Формат данных:

Поле | Тип | Примечание
--- | --- | ---
posX | Float | Координата по оси OX (то есть в направлении лево-право) местоположения клика
posY | Float | Координата по оси OY (то есть направлении верх-низ) местоположения клика
angle | Float | Угол направления в радианах, вычисляемый от положительного направления оси OX против часовой стрелки

Команда типа PublicMessageRequest вызывается в случае, когда игрок посылает сообщение в чате. Эта команда является стандартной для SmartFox сервера и она содержит только строку с передаваемым текстом.

Команда логина передаётся в самом начале после того, как клиент подсоединился к серверу. Только после успешного логина клиент будет перемещён в игровую комнату на сервере (комнаты - это одна из абстракций SmartFox сервера) и начнёт получать игровые данные. При логине клиент должен указать, какая модель выбрана в качестве игровой. Формат данных:

Поле | Тип | Примечание
--- | --- | ---
modelIndex | Byte | Допустимы два значения: 0 и 1. Значение 0 означает, что клиент будет играть маленькой, но быстрой моделью, а 1, что клиент будет играть большой, но медленной моделью
needMap | Bool | Если true, то после перемещения в игровую комнату, сервер пришлёт этому клиенту данные о том, какие области в игровом мире проходимы, а какие нет. Фактически эти данные представляют собой список отрезков, означающих непроходимые стены


# Передаваемые данные от сервера

Со стороны сервера на клиент данные передаются с помощью команд двух типов: ExtensionRespons-ы и обновление данных MMO-сущностей. Данные, которые передаются с помощью команд этих двух типов иногда дублируются. Это происходит, например, когда игрок делает выстрел. Чтобы он появился у всех синхронно, вызывается ExtensionRespons, однако в то же самое время происходит создание ММО-сущности, и после этого через некоторое время данные этой сущности синхронизируются на всех клиентах. Вот и получается, что сначала пришли данные о созданном выстреле, а потом они же, как результат синхронизации. С чатом примерно такая же ситуация.

Опишем сначала формат данных ExtensionRespons-ов.

Команда **RPCTowerResurect** вызывается, когда на сервере одна из башен переходит в активный режим. Эта команда вызывается у всех клиентов, в независимости от того, где они расположены.

Поле | Тип | Примечание
--- | --- | ---
id | Int | Порядковый номер башни
life | Int | Текущее число жизней башни (совпадает с максимальным количеством)
maxLife | Int | Максимальное число жизней башни

Команда **RPCMonsterStartAtack**. Вызывается в случае, когда противник (не игрок и не башня) начал атаку. Эту команду получают только те клиенты, которые располагаются в непосредственной близости от противника.

Поле | Тип | Примечание
--- | --- | ---
monsterId | Int | Порядковый номер противника
targetType | Byte | Тип цели, которая атакуется (0 - игрок, 1 - другой такой же противник, 2 - башня)
targetId | Int | Порядковый номер цели, которая атакуется
atackTime | Float | Время атаки в секундах. Фактически это время задержки перед моментом непосредственного нанесения урона. Если цель успеет за это время отойти на безопасное расстояние, то урон не будет нанесён.

Команда **RPCMonsterDead**. Вызывается в случае, если противник (не игрок и не башня) умирает. Команду получают только те клиенты, кто находится в непосредственной близости.

Поле | Тип | Примечание
--- | --- | ---
monsterId | Int | Порядковый номер умершего противника

Команда **RPCMonsterChangeState**. Вызывается в некоторых случаях, когда с противником что-то происходит. Используется для того, чтобы передать клиентам актуальную информацию и компенсировать какие бы то ни было рассинхроны данных. Команду получают только те клиенты, кто находится в непосредственной близости от противника.

Поле | Тип | Примечание
--- | --- | ---
id | Int | Порядковый номер противника
life | Int | Текущее число жизней
maxLife | Int | Максимальное число жизней
state | Byte | Одно из трёх значений: 0 - ничего не делает, 1 - движется в какую-то точку, 2 - преследует цель для атаки
speed | Float | Скорость передвижения
targetType | Byte | Одно из четырёх значений: 0 - нет цели, 1 - целью является игрок, 2 - целью является другой противник, 3 - целью является башня. Имеет смысл, если только state = 2
targetId | Int | Порядковый номер цели. Имеет смысл, если только state = 2
targetPositionX | Double | Местоположение по оси OX, в которое движется противник. Имеет смысл, если только state = 1
targetPositionY | Double |Местоположение по оси OY, в которое движется противник. Имеет смысл, если только state = 1
positionX | Double | Текущее местоположение по оси OX
positionY | Double | Текущее местоположение по оси OY

Команда **RPCClientUpdate**. Вызывается в случае, если что-то происходит с игроком. Используется для актуализации данных об игроках на клиентах. Команду получают лишь те клиенты, кто находится в непосредственной близости от игрока, о котором передаются данные.

Поле | Тип | Примечание
--- | --- | ---
id | Int | Порядковый номер игрока
life | Int | Текущее число жизней игрока
maxLife | Int | Максимальное число жизней игрока
locationX | Double | Текущее местоположение игрока по оси OX
locationY | Double | Текущее местоположение игрока по оси OY
angle | Float | Угол поворота (то есть куда направлено оружие игрока). Указывается в радианах от положительного направления оси OX против часовой стрелки
isMove | Bool | true, если игрок движется, и false в противном случае
moveAngle | Float | Направление движение игрока. Указывается в радианах от положительного направления оси OX против часовой стрелки. Имеет смысл только, если isMove = true
speed | Float | Скорость передвижения игрока

Команда **RPCStartBullet**.  Вызывается в случае, когда одна из игровых сущностей (игроки, башни или противники) делает выстрел. Команду получают лишь те клиенты, которые находятся в непосредственной близости от сущности, делающей выстрел. Формат данных:

Поле | Тип | Примечание
--- | --- | ---
hostType | Byte | Тип сущности, которая делает выстрел: 0 - игрок, 1 - противник, 2 - башня
hostId | Int | Порядковый номер сущности, которая делает выстрел
hostAngle | Float | Направление, в котором смотрит сущность в момент выстрела. Угол указывается в радианах и вычисляется от положительного направления оси OX против часовой стрелки
id | Int | Порядковый номер снаряда
bulletType | Byte | Тип снаряда. Может принимать три значения: 0 - движется прямолинейно и наносит урон первой встретившейся сущности, 1 - движет по баллистической траектории и наносит урон лишь в своей конечной точке, 2 - моментально достигает конечной точки и наносит урон по области
damageRadius | Float | Радиус области, в которой снаряд наносит урон. Используется в снарядах типа 1 и 2
speed | Float | Скорость перемещения снаряда. используется в снарядах типа 0 и 1
targetX | Double | Координата по оси OX конечной точки снаряда
targetY | Double | Координата по оси OY конечной точки снаряда
delay | Float | Время в секундах, которое снаряд ожидает после того, кок достиг своей конечной точки и перед тем, как непосредственно нанести урон. Используется в снарядах типа 2

Команда **RPCDestoyBullet**. Вызывается в момент, когда какой-то снаряд наносит урон. Команду получают лишь те клиенты, которые находятся в непосредственной близости от снаряда. Формат данных:

Поле | Тип | Примечание
--- | --- | ---
id | Int | Порядковый номер снаряда
type | Byte | Тип снаряда. Может принимать три значения: 0, 1 и 2
x | Double | Координата по оси OX места нанесения урона
y | Double | Координата по оси OY места нанесения урона
useBullet | Bool | true, если урон наносит снаряд, который до этого как-то перемещался в пространстве, и false, если урон наносит противник
hitData | SFSArray | Массив данных о нанесённом уроне. Каждый элемент массива имеет тип SFSObject

Формат каждой записи данных о нанесённом уроне:

Поле | Тип | Примечание
--- | --- | ---
type | Byte | Тип сущности, которой нанесён урон. Может принимать три значения: 0 - игрок, 1 - противник, 2 - башня
id | Int | Порядковый номер сущности, которой нанесён урон
life | Int | Текущее число жизней сущности после получения урона
maxLife | Int | Максимальное число жизней сущности, получившей урон
isDead | Bool | true, если после получения урона сущность уничтожается, false - в противном случае
blockTime | Float | Время в секундах, на которое блокируется активность сущности. Эта блокировка происходит в случае, когда сущность - это игрок, и число его жизней равно 0

Команда **RPCKillsMessage**. Вызывается на всех клиентах с некоторой периодичностью и содержит статистическую информацию о том, какой игрок кого сколько раз убил и сколько раз сам умер. Формат данных:

Поле | Тип | Примечание
--- | --- | ---
killsArray | SFSArray | Массив статистических данных. Каждый элемент массива имеет тип SFSObject

Формат каждой записи статистических данных:

Поле | Тип | Примечание
--- | --- | ---
id | Int | Порядковый номер игрока
name | String | Имя игрока
totalKills | Int | Общее число убийств игрока. Убийством считает только последний удар
playerKills | Int | Сколько раз игрок убил другого игрока
monsterKills | Int | Сколько раз игрок убил противника
towerKills | Int | Сколько башен разрушил игрок
death | Int | Сколько раз игрок умер

Команда **RPCMap**. Вызывается у клиента только один раз в тот момент, когда он подсоединяется к игровой комнате и лишь в том случае, если при логине было отмечено, что клиенту нужно получить данные о проходимости игровой карты. Формат данных:

Поле | Тип | Примечание
--- | --- | ---
points | DoubleArray | Массив чисел, задающих координаты отрезков - границ проходимых областей. Каждый отрезок задаётся четырьмя числами: первые два числа из каждой четвёрки массива задают координаты первого конца отрезка, а третий и четвёртый числа - координаты второго конца отрезка

Команда **RPCChatMessage**. Вызывается, когда кто-то из игроков отправляет сообщение в чат. Конечно, при отправке сообщение можно использовать стандартное событие `SFSEvent.PUBLIC_MESSAGE`, однако так как все игроки подсоединяются в комнату типа `MMORoom`, то публичные сообщения доходят только до тех игроков, кто находится в пределах AoI (области видимости). В этом случае нельзя увидеть, как кто-то ругается в чате, если он находится слишком далеко.

Поле | Тип | Примечание
--- | --- | ---
sender | String | Имя пользователя, отправившего сообщение
senderId | Int | Идентификационный номер пользователя, отправившего сообщение
message | String | Текст сообщения

Команда **RPCProcessCollect**. Вызывается в случаях, когда либо появился объект для сбора (сейчас есть только один такой объект - он восстанавливает здоровье), либо его кто-то собрал. Команду получают лишь те клиенты, которые находятся в непосредственной близости от снаряда. Формат данных:

Поле | Тип | Примечание
--- | --- | ---
id | Int | Порядковый номер объекта
type | Int | Тип объекта (0 - для лечения)
x | Double | Координата по оси OX местоположения объекта
y | Double | Координата по оси OY местоположения объекта
radius | Float | радиус объекта
emit | Bool | объект появился или наоборот должен исчезнуть


Ещё каждый клиент получает от сервера информацию об обновлении состояний MMO-сущностей. На стороне сервера есть два типа таких сущностей: игроки и те MMO-сущности, которые управляются сервером. Подобные обновления происходят, в том числе, когда какая-то сущность покидает (или наоборот появляется) в области видимости какого-то клиента. В этом случае тому клиенту присылается информация о том, кто исчез и кто появился. Есть три события, вызывающих обновления: UserVariablesUpdate, MMOItemVariablesUpdate и ProximityListUpdate. Каждому клиенту при вызове события UserVariablesUpdate присылаются данные об одном игроке, при вызове события MMOItemVariablesUpdate присылаются данные об одной MMO-сущности, управляемой сервером, а при вызове события ProximityListUpdate присылаются списки игроков и MMO-сущностей, которые покинули область видимости, а также те, которые наоборот, появились в области видимости.

Формат данных, присылаемых для каждого игрока:
Ключ | Тип | Примечание
--- | --- | ---
n | String | Имя игрока
mi | Int | Номер модели игрока: 0 или 1
cd | Float | Время ожидания в секундах после каждого выстрела, в течении которого нельзя сделать следующий выстрел
r | Float | Радиус игрока
ml | Int | Максимальное число жизней игрока
l | Int | Текущее число жизней игрока
sp | Float | Скорость передвижения игрока 
x | Double | Координата по оси OX текущего местоположения игрока
y | Double | Координата по оси OY текущего местоположения игрока
im | Bool | true, если игрок движется, и false иначе
ma | Float | Угол, показывающий текущее направление движения. Вычисляется от положительного направления оси OX против часовой стрелки
a | Float | Угол, показывающий направление, куда смотрит игрок

Каждая из MMO-сущностей содержит поле с ключом "sik", значение которого может быть 0 (для противников), 1 (для снарядов), 2 (для башен) и 3 (для собираемых объектов). В зависимости от того, каково значение по тому ключу, MMO-сущность содержит разный набор данных.

Для противников:

Ключ | Тип | Примечание
--- | --- | ---
i | Int | Порядковый номер противника
n | String | Имя противника
sp | Float | Скорость передвижения противника
sit | Int | Тип противника
r | Float | Радиус противника
ml | Int | Максимальное число жизней противника
l | Int | Текущее число жизней противника
md | Int | Урон, который может нанести противник
mdr | Float | Расстояние, на котором противник может нанести урон
x | Double | Координата по оси OX текущего местоположения противника
y | Double | Координата по оси OY текущего местоположения противника
st | Int | Номер состояния противника: 0 - стоит на месте, 1 - движется куда-то, 2 - преследует цель
tlx | Double | Координата по оси OX места, куда движется противник
tly | Double | Координата по оси OY места, куда движется противник
tet | Int | Тип цели противника: 0 - игрок, 1 - другой противник, 2 - башня
tei | Int | Порядковый номер цели противника


Для снарядов:

Ключ | Тип | Примечание
--- | --- | ---
i | Int | Порядковый номер снаряда
sp | Float | Скорость перемещения снаряда
sit | Int | Тип снаряда
r | Float | Радиус нанесения урона при попадании
bht | Int | Тип сущности, которая выпустила снаряд: 0 - игрок, 1 - противник, 2 - башня
bhi | Int | Порядковый номер сущности, выпустившей снаряд
x | Double | Координата по оси OX текущего местоположения снаряда
y | Double | Координата по оси OY текущего местоположения снаряда
tlx | Double | Координаты цели пои оси OX
tly | Double | Координаты цели по оси OY

Для башен:

Ключ | Тип | Примечание
--- | --- | ---
i | Int | Порядковый номер башни
sit | Int | Тип башни
n | String | Имя башни
ml | Int | Максимальное число жизней башни
l | Int | Текущее число жизней башни
r | Float | Радиус башни
x | Double | Координата по оси OX текущего местоположения башни
y | Double | Координата по оси OY текущего местоположения башни
tmmi | Float | Минимальное расстояние от башни, на котором может появиться противник
tmma | Float | Максимальное расстояние от башни, на котором может появиться противник
tar | Float | Расстояние, на котором башня наносит урон

Для собираемых объектов:

Ключ | Тип | Примечание
--- | --- | ---
i | Int | Порядковый номер объекта
sit | Int | Тип объекта
x | Double | Координата по оси OX местоположения объекта
y | Double | Координата по оси OY местоположения объекта
r | Float | Радиус объекта


# Подключение к серверу

В этом разделе на конкретных примерах (написанных на языке C# для Unity) опишем, как отправлять данные на сервер и как их оттуда получать. IP-адрес сервера может меняться время от времени. Актуальный ip-адрес приходит в ответ на GET-запрос

```php
https://arenagameplay.000webhostapp.com/ipAdress/ipDataCommunication.php?task=0&password=please
```

Порты, которые используются сервером для соединений с клиентами:

Порт | Примечание
--- | ---
9933 | Для соединений по протоколам TCP и UDP
8080 | Для соединений по протоколу WebSocket
8443 | Для соединений по протоколу WebSocket Security

Название зоны (это одна из абстракций SmartFox сервера), к которой надо подсоединяться - `OpenWorldZone`. Для соединения с сервером выполняем следующие команды:

```csharp
sfs = new SmartFox();
ConfigData cfg = new ConfigData();
cfg.Host = "127.0.0.1";
cfg.Port = 9933;
cfg.Zone = "OpenWorldZone";
sfs.Connect(cfg);
```

В случае, если соединяться планируется через WebSocket, то создание экземпляра сервера должно происходить так:

```csharp
sfs = new SmartFox(UseWebSocket.WS_BIN);
```

Если же соединяться планируется через WebSocket Security, то тогда так:

```csharp
sfs = new SmartFox(UseWebSocket.WSS_BIN);
```

После того, как экземпляр сервера `sfs` создан, в методе `FixedUpdate()` надо вызывать обновление его состояния:

```csharp
void FixedUpdate()
{
	sfs.ProcessEvents();
}
```

С течением времени клиент может принимать следующие события от сервера:

Событие | Примечание
--- | ---
`SFSEvent.CONNECTION` | Соединение с сервером установлено
`SFSEvent.CONNECTION_LOST` | Соединение с сервером потеряно. Клиент отключился, или его отключил кто-то другой
`SFSEvent.LOGIN` | Клиент залогинился под каким-то именем. 
`SFSEvent.ROOM_JOIN` | Клиент вошёл в игровую комнату. После этого начинается непосредственно игровой процесс
`SFSEvent.USER_VARIABLES_UPDATE` | Обновление данных об игроках
`SFSEvent.MMOITEM_VARIABLES_UPDATE` | Обновление данных об MMO-сущностях
`SFSEvent.PROXIMITY_LIST_UPDATE` | Обновление данных об области видимости клиента
`SFSEvent.EXTENSION_RESPONSE` | Внешняя команда от сервера
`SFSEvent.ADMIN_MESSAGE` | Текстовое сообщение от администратора. Такого сорта сообщения можно посылать индивидуальным клиентам через админку сервера

Дополнительно клиент может принимать событие `SFSEvent.PUBLIC_MESSAGE`, вместе с которым приходят сообщения в чате. Однако, посредством этого события приходят только сообщения, отправленные игроком в пределах AoI (области видимости). Так что лучше это событие вообще не использовать.

Последовательность событий до того, как начнётся непосредственно игра: `CONNECTION` -> `LOGIN` -> `ROOM_JOIN`. Остальные события из списка происходят во время игрового процесса. Чтобы зарегистрировать все эти события, надо **перед** командой `sfs.Connect(cfg)` написать следующее:

```csharp
sfs.AddEventListener(SFSEvent.CONNECTION, OnConnection);
sfs.AddEventListener(SFSEvent.CONNECTION_LOST, OnConnectionLost);
sfs.AddEventListener(SFSEvent.LOGIN, OnLogin);
sfs.AddEventListener(SFSEvent.ROOM_JOIN, OnRoomJoin);
sfs.AddEventListener(SFSEvent.ADMIN_MESSAGE, OnAdminMessage);
sfs.AddEventListener(SFSEvent.USER_VARIABLES_UPDATE, OnUserVarsUpdate);
sfs.AddEventListener(SFSEvent.MMOITEM_VARIABLES_UPDATE, OnMMOItemVarsUpdate);
sfs.AddEventListener(SFSEvent.PROXIMITY_LIST_UPDATE, OnProximityListUpdate);
sfs.AddEventListener(SFSEvent.EXTENSION_RESPONSE, OnExtensionResponse);
```

Также должны быть заранее созданы все используемые функции:

```csharp
public void OnConnection(BaseEvent evt)
{
	//...
}

public void OnConnectionLost(BaseEvent evt)
{
	//...
}

public void OnLogin(BaseEvent evt)
{
	//...
}

public void OnRoomJoin(BaseEvent evt)
{
	//...
}

public void OnAdminMessage(BaseEvent evt)
{
	//...
}

public void OnUserVarsUpdate(BaseEvent evt)
{
	//...
}

public void OnMMOItemVarsUpdate(BaseEvent evt)
{
	//...
}

public void OnProximityListUpdate(BaseEvent evt)
{
	//...
}

public void OnExtensionResponse(BaseEvent evt)
{
	//...
}
```

Далее опишем, как и какие данные можно получить при каждом событии.

Событие **CONNECTION**. Содержит параметр `success`, который равен true, если удалось соединиться с сервером, и false, в противном случае. При успешном соединении надо послать запрос на логин:

```csharp
public void OnConnection(BaseEvent evt)
{
	bool success = (bool) evt.Params["success"];
	if (success)
	{
		SFSObject data = new SFSObject();//создаём контейнер для данных
		data.PutByte("modelIndex", 0);//говорим к примеру, что хотим играть моделькой типа 0
		data.PutBool("needMap", false);//говорим, что карта проходимости не нужна
		sfs.Send(new LoginRequest("Name", "", "OpenWorldZone", data));//первый параметр - имя игрока, второй - пароль (он не нужен, поэтому оставляем его пустым)
	}
}
```

Событие **CONNECTION_LOST**. Содержит строковый параметр `reason`, в котором описана причина потери соединения. При потери соединения можно удалить экземпляр сервера `sfs`:

```csharp
public void OnConnectionLost(BaseEvent evt)
{
	sfs.Disconnect();
	
	sfs.RemoveEventListener(SFSEvent.CONNECTION, OnConnection);
	sfs.RemoveEventListener(SFSEvent.CONNECTION_LOST, OnConnectionLost);
	sfs.RemoveEventListener(SFSEvent.LOGIN, OnLogin);
	sfs.RemoveEventListener(SFSEvent.ROOM_JOIN, OnRoomJoin);
	sfs.RemoveEventListener(SFSEvent.ADMIN_MESSAGE, OnAdminMessage);
	sfs.RemoveEventListener(SFSEvent.PUBLIC_MESSAGE, OnPublicMessage);
	sfs.RemoveEventListener(SFSEvent.USER_VARIABLES_UPDATE, OnUserVarsUpdate);
	sfs.RemoveEventListener(SFSEvent.MMOITEM_VARIABLES_UPDATE, OnMMOItemVarsUpdate);
	sfs.RemoveEventListener(SFSEvent.PROXIMITY_LIST_UPDATE, OnProximityListUpdate);
	sfs.RemoveEventListener(SFSEvent.EXTENSION_RESPONSE, OnExtensionResponse);
	
	sfs = null;
}
```

Событие **LOGIN**. Содержит два параметра: `user` и `data`. Параметр `user` содержит объект, задающий текущего игрока. Параметр `data` содержит используемое имя. Это имя может отличаться от того, которое клиент указал при запросе логина. Дело в том, что на сервере не может быть несколько клиентов с одинаковыми именами. Поэтому, при возникновении повторов, дублирующие имена изменяются так, чтобы они все были разными. После логина **не надо** самостоятельно подсоединяться к игровой комнате, сервер это сделает автоматически.

```csharp
public void OnLogin(BaseEvent evt)
{
	User user = evt.Params["user"] as User;
	ISFSObject data = evt.Params["data"] as ISFSObject;
	string userName = data.getUtfString("$FS_NEW_LOGIN_NAME");
}
```

Событие **ROOM_JOIN**. Содержит один параметр `room`, задающий комнату, к которой подсоединился клиент.

```csharp
public void OnRoomJoin(BaseEvent evt)
{
	MMORoom room = evt.Params["room"] as MMORoom;
}
```

Событие **ADMIN_MESSAGE** (и, возможно, **PUBLIC_MESSAGE**). Содержит два параметра: `sender` и `message`. Параметр `sender` содержит объект, представляющий пользователя, пославшего сообщение, в `message` непосредственно сообщение.

```csharp
public void OnAdminMessage(BaseEvent evt)
{
	User sender = (User)evt.Params["sender"];
	string message = string)evt.Params["message"];
}
```

Событие **USER_VARIABLES_UPDATE**. Содержит один параметр `user`. Этот параметр задаёт игрока, для которого изменилось состояние.

```csharp
public void OnUserVarsUpdate(BaseEvent evt)
{
	User user = evt.Params["user"] as User;
	float positionX = (float)user.GetVariable("x").GetDoubleValue();//получаем значение параметра, для других аналогично
}
```

Событие **MMOITEM_VARIABLES_UPDATE**. Содержит один параметр `mmoItem`. Этот параметр задаёт MMO-сущность, у которой изменилось состояние.

```csharp
public void OnMMOItemVarsUpdate(BaseEvent evt)
{
	IMMOItem item = evt.Params["mmoItem"] as IMMOItem;
	float positionX = (float)item.GetVariable("x").GetDoubleValue();//получаем значение параметра, для других аналогично
}
```

Событие **PROXIMITY_LIST_UPDATE**. Содержит четыре параметра: `removedUsers`, `addedUsers`, `removedItems` и `addedItems`. Каждый из этих параметров является списком игроков (для `removedUsers` и `addedUsers`) или MMO-сущностей (для `removedItems` и `addedItems`).

```csharp
public void OnProximityListUpdate(BaseEvent evt)
{
	List<User> removedUsers = (List<User>) evt.Params["removedUsers"];
	List<User> addedUsers = (List<User>) evt.Params["addedUsers"];
	List<IMMOItem> removedItems = (List<IMMOItem>) evt.Params["removedItems"];
	List<IMMOItem> addedItems = (List<IMMOItem>) evt.Params["addedItems"];
}
```

Событие **EXTENSION_RESPONSE**. Это событие самое важное, так как посредством его сервер передаёт большинство команд, обеспечивающих игровую логику. Содержит два параметра: `cmd` и `params`. Первый параметр является строковым и совпадает с называнием команды, которую передаёт сервер. Второй параметр - это контейнер с передаваемыми данными, которые зависят от команды.

```csharp
public void OnExtensionResponse(BaseEvent evt)
{
	string cmd = (string) evt.Params["cmd"];
	ISFSObject parameters = (ISFSObject) evt.Params["params"];
	
	if (cmd == "RPCStartBullet")
    {
		int hostType = parameters.GetByte("hostType");
		int hostId = parameters.GetInt("hostId");
		//и так далее ...
	}
	else if(cmd == "RPCDestoyBullet")
	{
		//...
	}
	else if(cmd == "RPCKillsMessage")
	{
		//...
	}
	//и так далее, перечисляем все возможные имена команд, которые приходят от сервера
}
```

Как уже говорилось ранее, со стороны клиента на сервер можно передавать только три команды.

```csharp
public void SendDirection(byte dirIndex, float angle)
{
	if (sfs!= null)
	{
		ISFSObject parameters = SFSObject.NewInstance();
		parameters.PutByte("dirIndex", dirIndex);
		parameters.PutFloat("angle", angle);
		sfs.Send(new ExtensionRequest("RPCClientSendMovementKey", parameters, sfs.LastJoinedRoom));
	}
}

public void SendFire(float3 targetPoint, float modelAngle)
{
	if (sfs != null)
	{
		ISFSObject parameters = SFSObject.NewInstance();
		parameters.PutFloat("posX", targetPoint.x);
		parameters.PutFloat("posY", targetPoint.z);
		parameters.PutFloat("angle", modelAngle);
		sfs.Send(new ExtensionRequest("RPCFire", parameters, sfs.LastJoinedRoom));
	}
}

public void SendTextMessage(string message)
{
	if (sfs != null)
	{
		sfs.Send(new PublicMessageRequest(message));
	}
}
```